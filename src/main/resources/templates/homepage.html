<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
	<head>
		<meta charset="UTF-8">
		<title>HomePage</title>
		<!-- 引入项目图标 -->
		<link th:href="@{/icon/mydrive.png}" rel="icon">
		<!-- 引入layui -->
		<link th:href="@{/layui/css/layui.css}" rel="stylesheet">
		<!-- 引入bootstrap -->
		<link th:href="@{/bootstrap/css/bootstrap.min.css}" rel="stylesheet">

	</head>
	<body>
		<!-- 引入header -->
		<div th:insert="~{common :: myDriveHeaderBootstrap}"></div>
		<!-- 用于调试, 显示当前用户信息 -->
<!--		<div th:insert="~{common :: currentUserInfo}"></div>-->

		<!-- 显示用户所有文件夹 -->
		<div class="round-1">
			<div class="d-flex justify-content-lg-start align-items-center mb-2">
				<p class="p-1 mb-0">文件夹</p>

				<!-- 按钮触发模态框 -->
				<button type="button" class="btn btn-primary" data-toggle="modal" data-target="#createFolderModal">
					新增文件夹
				</button>
			</div>

			<ul th:each="folder : ${foldersList}" class="list-group rounded-1">
				<li class="list-group-item rounded-1">
					<a th:href="@{/user/homepage/{folderId}(folderId=${folder.getFolderId()})}" class="d-flex justify-content-between align-items-center text-dark text-decoration-none">
						<div class="d-flex align-items-center">
							<img th:src="@{/icon/icons8-folder.svg}" alt="folder" class="img-fluid mr-2">
							<span th:text="${folder.getFolderName()}">Folder Name</span>
							// TODO 创建删除文件夹按钮
						</div>
					</a>
				</li>
			</ul>

		</div>

		<br><br>

		<!-- 模态框 -->
		<div class="modal fade" id="createFolderModal" tabindex="-1" role="dialog" aria-labelledby="modelTitleId" aria-hidden="true">
			<div class="modal-dialog" role="document">
				<div class="modal-content">
					<div class="modal-header">
						<h5 class="modal-title">创建新文件夹</h5>
						<button type="button" class="close" data-dismiss="modal" aria-label="Close">
							<span aria-hidden="true">&times;</span>
						</button>
					</div>
					<div class="modal-body">
						<input type="text" class="form-control" id="folderNameInput" placeholder="输入文件夹名称">
					</div>
					<div class="modal-footer">
						<button type="button" class="btn btn-secondary" data-dismiss="modal">取消</button>
						<button type="button" class="btn btn-primary" onclick="createFolder()">创建</button>
					</div>
				</div>
			</div>
		</div>

		<!--		&lt;!&ndash; 引入js &ndash;&gt;-->
		<!--		<script th:src="@{/jquery/jquery-3.7.1.min.js}"></script>-->
		<!--		&lt;!&ndash; 引入bootstrap js &ndash;&gt;-->
		<!--		<script th:src="@{/bootstrap/js/bootstrap.js}"></script>-->
		<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
		<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>

		<!-- 处理创建文件夹js函数,和模态对话框 -->
		<script>
			function createFolder() {
				console.log('进入创建文件夹函数')
				var folderName = document.getElementById('folderNameInput').value.trim();
				if (folderName) {
					// 构建FormData对象
					var formData = new FormData();

					// 获得当前目录的folderId
					var parentFolderId = getCurrentFolderIdFromUrl();

					// 添加新建文件夹的名字
					formData.append('folderName', folderName);
					// 添加父文件夹id
					formData.append('parentFolderId', parentFolderId);

					// 发送AJAX请求到后端
					fetch('/user/createFolder', {
						method: 'POST',
						body: formData  // 使用FormData发送数据
					})
						.then(response => {
							if (response.ok) {
								return response.text();
							} else {
								return response.text().then(text => {
									throw new Error(text);
								})
							}
							//throw new Error('请求失败');
						})
						.then(data => {
							alert("文件夹创建成功");
							$('#createFolderModal').modal('hide'); // 关闭模态框
							window.location.reload(); //请求成功后刷新页面
						})
						.catch(error => {
							alert("文件夹创建失败: " + error.message);
						});
				} else {
					alert("文件夹名称不能为空！");
				}
			}

			// 获得当前所在目录的folderId, 根目录folderId为null
			function getCurrentFolderIdFromUrl() {
				var pathArray = window.location.pathname.split('/');
				var lastSegment = pathArray.pop()
				if (lastSegment === 'homepage') {
					return null;
				}
				return lastSegment;
			}
		</script>

		<!-- 显示当前用户的所有文件 -->
		<div class="round-1">
			<p class="p-1 ">文件</p>
			<ul th:each="file : ${filesList}" class="list-group rounded-1">
				<li class="list-group-item rounded-1">
					<div class="d-flex justify-content-between align-items-center">
						<div class="d-flex align-items-center">
							<img th:src="@{/icon/filetype-txt.svg}" alt="file" class="img-fluid mr-1">
							<span>[[${file.getFileName()}]]</span>
						</div>
						<div>
							<span class="me-2">
								<span th:if="${file.getFileSize() < 1024}">1 KB</span>
								<span th:if="${file.getFileSize() >= 1024 and file.getFileSize() < 1024.0 * 1024.0 }">[[${#numbers.formatDecimal(file.getFileSize() / 1024.0, 1, 2)}]] KB</span>
								<span th:if="${file.getFileSize() >= 1024 * 1024 and file.getFileSize() < 1024.0 * 1024.0 * 1024.0}">[[${#numbers.formatDecimal(file.getFileSize() / (1024.0 * 1024.0), 1, 2)}]]MB</span>
								<span th:if="${file.getFileSize() >= 1024 * 1024 * 1024}">[[${#numbers.formatDecimal(file.getFileSize() / (1024.0 * 1024.0 * 1024.0), 1, 2)}]] GB</span>
							</span>
							<a th:href="@{/user/download/{fileName} (fileName=${file.getFileName()})}" class="btn btn-sm btn-primary me-2">下载</a>
							<a th:href="@{/user/deleteFile/{fileName} (fileName=${file.getFileName()})}" class="btn btn-sm btn-danger me-1">删除</a>
						</div>
					</div>
				</li>
			</ul>
		</div>

		<!-- 进行文件上传 -->
		<div class="container my-4">
			<form id="fileUploadDiv" action="/user/uploadFile" method="post" enctype="multipart/form-data" class="upload-form">
				<div class="mb-3">
					<label for="fileInput" class="form-label" >请选择文件</label>
					<input type="file" class="form-control bg-secondary-subtle" id="fileInput" name="file">
				</div>
				<!-- 进度条 -->
				<div class="progress my-3" style="height: 20px;">
					<div id="progressBar" class="progress-bar bg-success-subtle" role="progressbar" style="width: 0%;"></div>
				</div>
				<!-- 进度信息 -->
				<div id="progressText" class="progress-text mb-3"></div>
			</form>
			<button id="uploadButton" class="btn btn-danger">上传文件</button>
			<!-- hash值计算状态 -->
			<div id="hashStatus" class="hash-status mt-3"></div>
		</div>

		<!-- 处理文件上传逻辑 -->
		<script th:inline="javascript">
			let selectedFile; // 用于存储选中的文件

			// 获得当前父目录的id
			var parentFolderId = getCurrentFolderIdFromUrl()

			// 监听文件选择变化
			document.getElementById('fileInput').addEventListener('change', (event) => {
				selectedFile = event.target.files[0]; // 保存选中的文件
			});

			document.getElementById('uploadButton').addEventListener('click', async () => {
				if (selectedFile) {
					showHashCalculationStatus('正在计算文件哈希,请稍候...');
					const fileHash = await calculateHash(selectedFile);
					showHashCalculationStatus(selectedFile.name + ' 文件哈希计算完成:' + fileHash);

					// 设置分片大小位10MB
					const chunkSize = 10 * 1024 * 1024;
					const totalChunks = Math.ceil(selectedFile.size / chunkSize);
					let uploadSuccess = true; // 追踪文件上传是否成功

					// 进行文件初始化设置
					const fileId = await initializeFileUpload(selectedFile.name, fileHash, totalChunks, parentFolderId);
					console.log('文件id是' + fileId);

					for (let i = 0; i < totalChunks; i++) {
						const chunk = selectedFile.slice(i * chunkSize, (i + 1) * chunkSize);
						const chunkHash = await calculateHash(chunk)
						console.log(`Chunk ${i}: Hash: ${chunkHash}`);

						// 检查分片是否需要上传,如果服务端存储该分片则不用上传
						const chunkExist = await checkChunkExist(chunkHash, fileId, i);
						if (chunkExist) {
							console.log(`Chunk ${i} already exists, skipping upload.`);
							updateProgress(i + 1, totalChunks);
							continue;
						}

						// TODO 数据库修改该上传逻辑需要修改
						const formData = new FormData();

						formData.append('chunk', chunk);
						formData.append('fileId', fileId);
						formData.append('parentFolderId', parentFolderId);
						formData.append('chunkIndex', i);
						formData.append('chunkHash', chunkHash);
						formData.append('totalChunks', totalChunks);

						try {
							const response = await fetch('/user/uploadChunk', {
								method: 'POST',
								body: formData
							});
							// if (!response.ok) {
							// 	throw new Error('Upload chunk' + i + ' fail');
							// }
							//更新进度条
							updateProgress(i + 1, totalChunks);
						} catch (error) {
							console.error(error);
							alert(`上传失败: ${error.message}`);
							uploadSuccess = false;
							break;
						}
					}
					if (uploadSuccess) {
						// 如果所有分片都成功上传，则刷新页面
						window.location.reload();
					}

				} else {
					alert("请先选择一个文件! ");
				}
			})

			// 文件上传初始化操作
			async function initializeFileUpload(fileName, fileHash, totalChunks, parentFolderId) {
				const formData = new FormData();
				formData.append('fileName', fileName);
				formData.append('fileHash', fileHash);
				formData.append('totalChunks', totalChunks);
				if (parentFolderId != null) {
					formData.append('parentFolderId', parentFolderId);
				}
				try {
					const response = await fetch('/user/initializeFileUpload', {
						method: 'POST',
						body: formData
					});

					if (!response.ok) {
						throw new Error('Failed to initialize file upload' + await response.text());
					}

					// 获得response的内容
					const fileId = await response.text();
					console.log('initialize function fileId: ' + fileId);
					return parseInt(fileId, 10);
				} catch (error) {
					console.log('Initialization error: ', error);
					alert('文件初始化操作失败');
				}
			}

			// 判断服务器端是否已经存储了该分片
			async function checkChunkExist(chunkHash, fileId, chunkIndex) {
				const formData = new FormData();
				formData.append('chunkHash', chunkHash);
				formData.append('fileId', fileId);
				formData.append('chunkIndex', chunkIndex);

				// 发送POST请求给服务端
				const response = await fetch('/user/checkChunkExist', {
					method: 'POST',
					body: formData
				})
				const result = await response.text();
				console.log('checkChunkExist function: current chunkHash' + chunkHash + ' fileId' + fileId + ' index' + chunkIndex);
				return result.toLowerCase() === 'true';
			}

			// 计算hash
			async function calculateHash(file) {
				// 读取文件内容
				const arrayBuffer = await file.arrayBuffer();

				// 计算哈希值
				const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);

				// 将ArrayBuffer转换为十六进制字符串
				const hashArray = Array.from(new Uint8Array(hashBuffer));
				const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

				return hashHex;
			}

			// 更新进度条
			function updateProgress(currentChunk, totalChunks) {
				const progressPercentage = (currentChunk / totalChunks) * 100;
				document.getElementById('progressBar').style.width = `${progressPercentage}%`;
				document.getElementById('progressText').innerText = `上传进度: ${progressPercentage.toFixed(2)}%`;
			}

			function showHashCalculationStatus(message) {
				const hashStatusElement = document.getElementById('hashStatus');
				if (hashStatusElement) {
					hashStatusElement.innerText = message;
				}
			}

			// 获得当前url的最后一个路径段
			function getLastPathSegment() {
				var pathArray = window.location.pathname.split('/');
				var lastSegment = pathArray.pop();
				return lastSegment;
			}

			// 获得当前所在目录的folderId, 根目录folderId为null
			function getCurrentFolderIdFromUrl() {
				var pathArray = window.location.pathname.split('/');
				var lastSegment = pathArray.pop()
				if (lastSegment === 'homepage') {
					return null;
				}
				return lastSegment;
			}
		</script>


		<div th:if="${uploadMessage}">
			[[${uploadMessage}]]
		</div>
	</body>
</html>